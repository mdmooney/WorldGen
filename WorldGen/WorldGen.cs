using System;
using System.Collections.Generic;
using System.Linq;

namespace WorldGen
{
    /**
     * <summary>
     * WorldGenerator class, handling the generation of an entire world from
     * start to finish.
     * 
     * This may be split up or otherwise changed radically in the future as the
     * generation process gets more complex.
     * </summary>
     */
    class WorldGenerator
    {
        /// <summary>
        /// This internal class represents a landmasss being generated by a
        /// LandmassExpander. It tracks how many land Hexes have been placed, how
        /// many Hexes we're trying to place, and the Coords of modified Hexes.
        /// </summary>
        private class Landmass
        {
            public int totalHexes;
            public int remainingHexes;
            public List<Coords> hexes = new List<Coords>();
            public List<Coords> shoreHexes = new List<Coords>();
        }

        private HexMap map;
        private List<Landmass> landmasses;

        // Ratio of land:water in this world. Currently a constant at 3:7,
        // but will be alterable by the user later.
        const double WORLD_RATIO = 0.30;

        // Maximum number of landmasses permitted in this world.
        const int MAX_LANDMASSES = 10;

        // Default temperature band constants, representing the fraction of
        // the world that should be a given temperature.
        private static readonly double TempRatioHot = 0.10;
        private static readonly double TempRatioWarm = 0.22;
        private static readonly double TempRatioTemperate = 0.36;
        private static readonly double TempRatioCool = 0.22;
        private static readonly double TempRatioCold = 0.10;

        /**
         * <summary>
         * WorldGenerator constructor requires a HexMap, which will hold the
         * world that is about to be generated.
         * 
         * Does some basic setup, like determining how many landmasses will
         * exist in the world and how many Hexes they should contain, but does
         * not perform any actual generation.
         * </summary>
         * <param name="map">HexMap to generate a world in.</param>
         */
        public WorldGenerator(HexMap map)
        {
            Random rnd = new Random();
            this.map = map;
            int worldTotal = (map.Width * map.Height);
            double overallTotalDec = (double)worldTotal;
            int totalLandHexes = (int)(overallTotalDec * WORLD_RATIO);
            int remainingHexes = totalLandHexes;

            landmasses = new List<Landmass>();
            int numLandmasses = rnd.Next(1, MAX_LANDMASSES);

            for (int i = 0; i < numLandmasses; i++)
            {
                Landmass landmass = new Landmass();
                int massHexes;
                if (i != numLandmasses - 1)
                {
                    massHexes = rnd.Next(1, remainingHexes / 2);
                }
                else
                {
                    massHexes = remainingHexes;
                }

                remainingHexes -= massHexes;
                landmass.totalHexes = landmass.remainingHexes = massHexes;
                landmasses.Add(landmass);
            }
        }

        /**
         * <summary>
         * Primary work method of this class, generating the entire world in
         * the given HexMap.
         * 
         * This will very likely be split into smaller methods in the near future.
         * </summary>
         */
        public void Generate()
        {
            Random rnd = new Random();
            for (int i = 0; i < landmasses.Count; i++)
            {
                Landmass mass = landmasses[i];
                List<Coords> allCoords = map.GetAllCoords();
                LandmassExpander lEx = new LandmassExpander(map);
                mass.hexes = lEx.Expand(allCoords, mass.totalHexes);
                mass.totalHexes = mass.hexes.Count;

                // Create shore/shallow water hexes adjacent to each hex of this landmass
                foreach (Coords owned in mass.hexes)
                {
                    if (map.BordersOcean(owned))
                    {
                        List<Coords> shoreHexes = map.GetAdjacentOceanHexes(owned);
                        foreach (Coords shoreCoords in shoreHexes)
                        {
                            map.SetTypeAt(shoreCoords, Hex.HexType.Shore);
                            mass.shoreHexes.Add(shoreCoords);
                        }
                    }
                }

                // Elevation
                int passes = rnd.Next(1, 5);
                List<Coords> eleHexes = new List<Coords>(mass.hexes);
                int range = eleHexes.Count;
                
                for (int pass = 1; pass <= passes; pass++)
                {
                    int toElevate = rnd.Next(range / 5, (int)(range * 0.75));
                    if (toElevate == 0) break;

                    List<Coords> elevatedOnThisPass = new List<Coords>(eleHexes);

                    int seedPoints = rnd.Next(1, 5);
                    for (int seedPoint = 0; seedPoint < seedPoints; seedPoint++)
                    {
                        if (toElevate <= 0) break;
                        int elevating = rnd.Next(1, toElevate);
                        HeightExpander hEx = new HeightExpander(map, pass);
                        List<Coords> tempHexes = hEx.Expand(eleHexes, elevating);
                        toElevate -= tempHexes.Count;
                        elevatedOnThisPass.AddRange(tempHexes);
                    }

                    range = elevatedOnThisPass.Count;
                    eleHexes = elevatedOnThisPass;
                }

                // Rivers
                passes = rnd.Next(1, 5);
                int totalRiverHexes = 50;
                for (int pass = 1; pass <= passes; pass++)
                {
                    RiverExpander rEx = new RiverExpander(map);
                    List<Coords> landAndShore = mass.hexes.Union(mass.shoreHexes).ToList();
                    List<Coords> riverHexes = rEx.Expand(landAndShore, totalRiverHexes);
                    totalRiverHexes -= riverHexes.Count;
                }

                // Temperature
                SetTemperatures(2.0);
            }
        }

        /**
         * <summary>
         * Sets temperatures for hexes in the nascent world.
         * Currenlty, temperature is based solely on latitude, with hexes closer
         * to the equator (center of the map) being warmer, and hexes closer to
         * the poles (top and bottom of the map) being cooler.
         * This can be scaled for warmer or cooler worlds.
         * </summary>
         * <param name="scale">Scaling factor. At values greater than 1.0 the
         * world will be cooler overall, and at values less than 1.0 it will
         * be warmer. At extreme values (approaching 0.0 or 2.0), temperature
         * levels on the opposite extreme will not exist in the world.</param>
         */
        public void SetTemperatures(double scale = 1.0)
        {
            // first locate the equator
            int equatorRow = map.Height / 2;
            int currBand, coldBand;
            currBand = coldBand = (int)(equatorRow * TempRatioCold);
            int coolBand = (currBand += (int)(equatorRow * TempRatioCool));
            int temperateBand = (currBand += (int)(equatorRow * TempRatioTemperate));
            int warmBand = (currBand += (int)(equatorRow * TempRatioWarm));
            int hotBand = (currBand += (int)(equatorRow * TempRatioHot));


            bool flip = false;
            if (scale < 1.0)
            {
                flip = true;
                scale = 2.0 - scale;

                // take abs(band row - equatorRow) of each band
                coldBand = Math.Abs(coldBand - equatorRow);
                coolBand = Math.Abs(coolBand - equatorRow);
                temperateBand = Math.Abs(temperateBand - equatorRow);
                warmBand = Math.Abs(warmBand - equatorRow);
                hotBand = Math.Abs(hotBand - equatorRow);
            }
            coldBand = (int)(coldBand * scale);
            coolBand = (int)(coolBand * scale);
            temperateBand = (int)(temperateBand * scale);
            warmBand = (int)(warmBand * scale);
            hotBand = (int)(hotBand * scale);

            if (flip)
            {
                // take abs(band row - equatorRow) of each band
                coldBand = equatorRow - coldBand;
                coolBand = equatorRow - coolBand;
                temperateBand = equatorRow - temperateBand;
                warmBand = equatorRow - warmBand;
                hotBand =  equatorRow - hotBand;
            }


            for (int y = 0; y < equatorRow; y++)
            {
                for (int x = 0; x < map.Width; x++)
                {
                    if (y < coldBand)
                    {
                        map.SetTemperatureAt(new Coords(x, y), Hex.TemperatureLevel.Cold);
                        map.SetTemperatureAt(new Coords(x, map.Height - 1 - y), Hex.TemperatureLevel.Cold);
                    }
                    else if (y < coolBand)
                    {
                        map.SetTemperatureAt(new Coords(x, y), Hex.TemperatureLevel.Cool);
                        map.SetTemperatureAt(new Coords(x, map.Height - 1 - y), Hex.TemperatureLevel.Cool);
                    }
                    else if (y < temperateBand)
                    {
                        map.SetTemperatureAt(new Coords(x, y), Hex.TemperatureLevel.Temperate);
                        map.SetTemperatureAt(new Coords(x, map.Height - 1 - y), Hex.TemperatureLevel.Temperate);
                    }
                    else if (y < warmBand)
                    {
                        map.SetTemperatureAt(new Coords(x, y), Hex.TemperatureLevel.Warm);
                        map.SetTemperatureAt(new Coords(x, map.Height - 1 - y), Hex.TemperatureLevel.Warm);
                    }
                    else
                    {
                        map.SetTemperatureAt(new Coords(x, y), Hex.TemperatureLevel.Hot);
                        map.SetTemperatureAt(new Coords(x, map.Height - 1 - y), Hex.TemperatureLevel.Hot);
                    }
                }
            }
        }
    }
}
